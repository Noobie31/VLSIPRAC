{
  "topics": [
    {
      "title": "enc decoder",
      "body": "//======================================================\n// 4:2 ENCODER and 2:4 DECODER\n// Behavioral, Dataflow, and Structural Modeling\n// With Truth Tables (for documentation)\n//======================================================\n\n\n//======================================================\n// 4:2 ENCODER\n//======================================================\n\n/*\n----------------------------\n| INPUT (I3 I2 I1 I0) | Y1 Y0 |\n----------------------------\n|     0001            |  00   |\n|     0010            |  01   |\n|     0100            |  10   |\n|     1000            |  11   |\n----------------------------\nNote: Only one input should be HIGH at a time.\n*/\n\n// Behavioral Modeling\nmodule encoder4to2_beh (\n    input [3:0] I,\n    output reg [1:0] Y\n);\n    always @(*) begin\n        case (I)\n            4'b0001: Y = 2'b00;\n            4'b0010: Y = 2'b01;\n            4'b0100: Y = 2'b10;\n            4'b1000: Y = 2'b11;\n            default: Y = 2'b00;\n        endcase\n    end\nendmodule\n\n// Dataflow Modeling\nmodule encoder4to2_data (\n    input [3:0] I,\n    output [1:0] Y\n);\n    assign Y[0] = I[1] | I[3];\n    assign Y[1] = I[2] | I[3];\nendmodule\n\n// Structural Modeling\nmodule encoder4to2_struct (\n    input [3:0] I,\n    output [1:0] Y\n);\n    or (Y[0], I[1], I[3]);\n    or (Y[1], I[2], I[3]);\nendmodule\n\n\n//======================================================\n// 2:4 DECODER\n//======================================================\n\n/*\n----------------------------\n| INPUT (A1 A0) | Y3 Y2 Y1 Y0 |\n----------------------------\n|     00        | 0001        |\n|     01        | 0010        |\n|     10        | 0100        |\n|     11        | 1000        |\n----------------------------\nNote: Only one output will be HIGH for each input combination.\n*/\n\n// Behavioral Modeling\nmodule decoder2to4_beh (\n    input [1:0] A,\n    output reg [3:0] Y\n);\n    always @(*) begin\n        case (A)\n            2'b00: Y = 4'b0001;\n            2'b01: Y = 4'b0010;\n            2'b10: Y = 4'b0100;\n            2'b11: Y = 4'b1000;\n        endcase\n    end\nendmodule\n\n// Dataflow Modeling\nmodule decoder2to4_data (\n    input [1:0] A,\n    output [3:0] Y\n);\n    assign Y[0] = ~A[1] & ~A[0];\n    assign Y[1] = ~A[1] &  A[0];\n    assign Y[2] =  A[1] & ~A[0];\n    assign Y[3] =  A[1] &  A[0];\nendmodule\n\n// Structural Modeling\nmodule decoder2to4_struct (\n    input [1:0] A,\n    output [3:0] Y\n);\n    wire nA0, nA1;\n\n    not (nA0, A[0]);\n    not (nA1, A[1]);\n\n    and (Y[0], nA1, nA0);\n    and (Y[1], nA1, A[0]);\n    and (Y[2], A[1], nA0);\n    and (Y[3], A[1], A[0]);\nendmodule\n"
    },
    {
      "title": "Mux Dmux",
      "body": "//======================================================\n// 4:1 MULTIPLEXER and 1:4 DEMULTIPLEXER\n// Behavioral, Dataflow, and Structural Modeling\n//======================================================\n\n//----------------------\n// 4:1 MULTIPLEXER\n//----------------------\n\n// Behavioral Modeling\nmodule mux4to1_beh (\n    input [3:0] I,\n    input [1:0] S,\n    output reg Y\n);\n    always @(*) begin\n        case (S)\n            2'b00: Y = I[0];\n            2'b01: Y = I[1];\n            2'b10: Y = I[2];\n            2'b11: Y = I[3];\n        endcase\n    end\nendmodule\n\n// Dataflow Modeling\nmodule mux4to1_data (\n    input [3:0] I,\n    input [1:0] S,\n    output Y\n);\n    assign Y = (S == 2'b00) ? I[0] :\n               (S == 2'b01) ? I[1] :\n               (S == 2'b10) ? I[2] :\n                              I[3];\nendmodule\n\n// Structural Modeling\nmodule mux4to1_struct (\n    input [3:0] I,\n    input [1:0] S,\n    output Y\n);\n    wire [3:0] and_out;\n    wire [1:0] nS;\n\n    not (nS[0], S[0]);\n    not (nS[1], S[1]);\n\n    and (and_out[0], I[0], nS[1], nS[0]);\n    and (and_out[1], I[1], nS[1], S[0]);\n    and (and_out[2], I[2], S[1], nS[0]);\n    and (and_out[3], I[3], S[1], S[0]);\n\n    or (Y, and_out[0], and_out[1], and_out[2], and_out[3]);\nendmodule\n\n\n//======================================================\n// 1:4 DEMULTIPLEXER\n//======================================================\n\n// Behavioral Modeling\nmodule demux1to4_beh (\n    input D,\n    input [1:0] S,\n    output reg [3:0] Y\n);\n    always @(*) begin\n        case (S)\n            2'b00: Y = {3'b000, D};\n            2'b01: Y = {2'b00, D, 1'b0};\n            2'b10: Y = {1'b0, D, 2'b00};\n            2'b11: Y = {D, 3'b000};\n        endcase\n    end\nendmodule\n\n// Dataflow Modeling\nmodule demux1to4_data (\n    input D,\n    input [1:0] S,\n    output [3:0] Y\n);\n    assign Y[0] = D & ~S[1] & ~S[0];\n    assign Y[1] = D & ~S[1] &  S[0];\n    assign Y[2] = D &  S[1] & ~S[0];\n    assign Y[3] = D &  S[1] &  S[0];\nendmodule\n\n// Structural Modeling\nmodule demux1to4_struct (\n    input D,\n    input [1:0] S,\n    output [3:0] Y\n);\n    wire [1:0] nS;\n\n    not (nS[0], S[0]);\n    not (nS[1], S[1]);\n\n    and (Y[0], D, nS[1], nS[0]);\n    and (Y[1], D, nS[1], S[0]);\n    and (Y[2], D, S[1], nS[0]);\n    and (Y[3], D, S[1], S[0]);\nendmodule\n"
    },
    {
      "title": "flip flops jk sr t d",
      "body": "//======================================================\n// JK, SR, D, T FLIP-FLOPS\n// For Vivado - single file containing for each flip-flop:\n//   - Truth table (comment)\n//   - Behavioral model (posedge clock)\n//   - Dataflow model (Boolean next-state expression + D-FF instance)\n//   - Structural model (gate-level combinational network + D-FF instance)\n// Notes:\n//  - All FFs are positive-edge triggered, no async reset or preset.\n//  - A small generic D flip-flop (dff_posedge) is provided and used by\n//    dataflow & structural variants to separate combinational next-state\n//    logic from sequential storage.\n//  - For SR when S=R=1 the result is undefined/invalid; simulator will show 'x' for the behavioral case.\n//======================================================\n\n//------------------------------------------------------\n// Generic positive-edge triggered D flip-flop (sequential primitive)\n//------------------------------------------------------\nmodule dff_posedge (\n    input  wire D,\n    input  wire clk,\n    output reg  Q\n);\n    always @(posedge clk) begin\n        Q <= D;\n    end\nendmodule\n\n\n//======================================================\n// 1) JK FLIP-FLOP\n//======================================================\n/*\nTruth Table (JK, positive-edge triggered)\n------------------------------------------\n| J | K | Q(next) | Operation            |\n------------------------------------------\n| 0 | 0 | Q       | No change (hold)     |\n| 0 | 1 | 0       | Reset                |\n| 1 | 0 | 1       | Set                  |\n| 1 | 1 | ~Q      | Toggle               |\n------------------------------------------\n*/\n\n//\n// Behavioral model\n//\nmodule jk_ff_beh (\n    input wire J,\n    input wire K,\n    input wire clk,\n    output reg Q\n);\n    always @(posedge clk) begin\n        case ({J,K})\n            2'b00: Q <= Q;        // hold\n            2'b01: Q <= 1'b0;     // reset\n            2'b10: Q <= 1'b1;     // set\n            2'b11: Q <= ~Q;       // toggle\n        endcase\n    end\nendmodule\n\n//\n// Dataflow model\n//  D_next = J & ~Q | ~K & Q  (standard JK to D equation)\n//  Use dff_posedge to store the computed D_next at posedge clk\n//\nmodule jk_ff_data (\n    input wire J,\n    input wire K,\n    input wire clk,\n    output wire Q\n);\n    wire D_next;\n    wire Q_internal;\n\n    // D_next expression (combinational)\n    assign D_next = (J & ~Q_internal) | (~K & Q_internal);\n\n    // sequential storage\n    dff_posedge dff_inst (.D(D_next), .clk(clk), .Q(Q_internal));\n\n    // expose Q\n    assign Q = Q_internal;\nendmodule\n\n//\n// Structural model\n// Build D_next from gates explicitly, then feed to dff_posedge\n//\nmodule jk_ff_struct (\n    input wire J,\n    input wire K,\n    input wire clk,\n    output wire Q\n);\n    wire Q_internal;\n    wire nQ;\n    wire term1, term2, D_next;\n\n    // Invert Q for term calculation (will be generated from Q_internal)\n    not (nQ, Q_internal);\n\n    // term1 = J & ~Q\n    and (term1, J, nQ);\n\n    // term2 = ~K & Q\n    not (/*open*/ , K); // placeholder to show inversion; we'll create nK separately\nendmodule\n\n// Note: For structural JK we need nK and a way to reference Q_internal in gate-level.\n// To keep the structural block synthesizable and clear, implement structural JK\n// fully below (without using incomplete placeholders).\n\nmodule jk_ff_struct (\n    input wire J,\n    input wire K,\n    input wire clk,\n    output wire Q\n);\n    wire Q_internal;\n    wire nQ, nK;\n    wire term1, term2, D_next;\n\n    not (nQ, Q_internal);\n    not (nK, K);\n\n    and (term1, J, nQ);      // J & ~Q\n    and (term2, nK, Q_internal); // ~K & Q\n\n    or  (D_next, term1, term2);  // D_next = J&~Q | ~K&Q\n\n    dff_posedge dff_inst (.D(D_next), .clk(clk), .Q(Q_internal));\n\n    assign Q = Q_internal;\nendmodule\n\n\n//======================================================\n// 2) SR FLIP-FLOP (basic S-R latch implemented as posedge FF)\n//======================================================\n/*\nTruth Table (SR, positive-edge triggered)\n-------------------------------------------------\n| S | R | Q(next) | Operation                   |\n-------------------------------------------------\n| 0 | 0 | Q       | No change (hold)            |\n| 0 | 1 | 0       | Reset                       |\n| 1 | 0 | 1       | Set                         |\n| 1 | 1 | X/undef | Invalid / Indeterminate     |\n-------------------------------------------------\nNote: S=R=1 is invalid for a simple SR FF (indeterminate).\n*/\n\n//\n// Behavioral model\n//\nmodule sr_ff_beh (\n    input wire S,\n    input wire R,\n    input wire clk,\n    output reg Q\n);\n    always @(posedge clk) begin\n        case ({S,R})\n            2'b00: Q <= Q;        // hold\n            2'b01: Q <= 1'b0;     // reset\n            2'b10: Q <= 1'b1;     // set\n            2'b11: Q <= 1'bx;     // invalid/indeterminate (simulation only)\n            default: Q <= 1'bx;\n        endcase\n    end\nendmodule\n\n//\n// Dataflow model\n// We use the canonical expression: D_next = S | (~R & Q)\n// But that expression does not flag the invalid S=R=1 explicitly; simulation will yield 1\n// To represent the undefined case in dataflow would require extra handling; here we show the typical next-state logic.\n// Use dff_posedge to store D_next.\n//\nmodule sr_ff_data (\n    input wire S,\n    input wire R,\n    input wire clk,\n    output wire Q\n);\n    wire Q_internal;\n    wire D_next;\n\n    // canonical next-state (note: for S=R=1 this yields 1; SR invalidity is documented)\n    assign D_next = S | (~R & Q_internal);\n\n    dff_posedge dff_inst (.D(D_next), .clk(clk), .Q(Q_internal));\n    assign Q = Q_internal;\nendmodule\n\n//\n// Structural model\n// D_next = S + ( ~R * Q )\n// Build using gates and feed to dff_posedge\n//\nmodule sr_ff_struct (\n    input wire S,\n    input wire R,\n    input wire clk,\n    output wire Q\n);\n    wire Q_internal;\n    wire nR;\n    wire and_term, D_next;\n\n    not (nR, R);\n    and (and_term, nR, Q_internal);\n    or  (D_next, S, and_term);\n\n    dff_posedge dff_inst (.D(D_next), .clk(clk), .Q(Q_internal));\n    assign Q = Q_internal;\nendmodule\n\n\n//======================================================\n// 3) D FLIP-FLOP\n//======================================================\n/*\nTruth Table (D, positive-edge triggered)\n-------------------------------\n| D | Q(next) | Operation     |\n-------------------------------\n| 0 | 0       | Q <= 0        |\n| 1 | 1       | Q <= 1        |\n-------------------------------\n(Direct data input)\n*/\n\n//\n// Behavioral model (direct D storage)\n//\nmodule d_ff_beh (\n    input wire D,\n    input wire clk,\n    output reg Q\n);\n    always @(posedge clk) begin\n        Q <= D;\n    end\nendmodule\n\n//\n// Dataflow model\n// Just use dff_posedge (this is both dataflow and sequential storage; for completeness)\n//\nmodule d_ff_data (\n    input wire D,\n    input wire clk,\n    output wire Q\n);\n    // direct connection to primitive D-FF\n    dff_posedge dff_inst (.D(D), .clk(clk), .Q(Q));\nendmodule\n\n//\n// Structural model\n// Structural D-FF: there is no combinational next-state, so just instantiate dff_posedge\n//\nmodule d_ff_struct (\n    input wire D,\n    input wire clk,\n    output wire Q\n);\n    dff_posedge dff_inst (.D(D), .clk(clk), .Q(Q));\nendmodule\n\n\n//======================================================\n// 4) T FLIP-FLOP\n//======================================================\n/*\nTruth Table (T, positive-edge triggered)\n------------------------------------------\n| T | Q(next) | Operation                 |\n------------------------------------------\n| 0 | Q       | No change (hold)          |\n| 1 | ~Q      | Toggle                    |\n------------------------------------------\nWe can express T-FF as D-FF with D = T ^ Q (exclusive-or) or D = T ? ~Q : Q\n*/\n\n//\n// Behavioral model\n//\nmodule t_ff_beh (\n    input wire T,\n    input wire clk,\n    output reg Q\n);\n    always @(posedge clk) begin\n        if (T)\n            Q <= ~Q;   // toggle\n        else\n            Q <= Q;    // hold (redundant but explicit)\n    end\nendmodule\n\n//\n// Dataflow model\n// D_next = T ^ Q_internal  (toggle when T=1)\n// Use dff_posedge to store D_next\n//\nmodule t_ff_data (\n    input wire T,\n    input wire clk,\n    output wire Q\n);\n    wire Q_internal;\n    wire D_next;\n\n    assign D_next = T ^ Q_internal; // XOR\n\n    dff_posedge dff_inst (.D(D_next), .clk(clk), .Q(Q_internal));\n    assign Q = Q_internal;\nendmodule\n\n//\n// Structural model\n// Build D_next = T XOR Q from gates, then use dff_posedge\n//\nmodule t_ff_struct (\n    input wire T,\n    input wire clk,\n    output wire Q\n);\n    wire Q_internal;\n    wire nQ;\n    wire a1, a2, D_next;\n\n    // XOR using gates: A ^ B = (A & ~B) | (~A & B)\n    not (nQ, Q_internal);\n    and (a1, T, nQ);    // T & ~Q\n    not (/*tmp*/, T);   // create nT\nendmodule\n\n// Complete structural T-FF properly (avoid placeholder)\nmodule t_ff_struct (\n    input wire T,\n    input wire clk,\n    output wire Q\n);\n    wire Q_internal;\n    wire nQ, nT;\n    wire term1, term2, D_next;\n\n    not (nQ, Q_internal);\n    not (nT, T);\n\n    and (term1, T, nQ);   // T & ~Q\n    and (term2, nT, Q_internal); // ~T & Q\n\n    or  (D_next, term1, term2);   // D_next = (T & ~Q) | (~T & Q) = T ^ Q\n\n    dff_posedge dff_inst (.D(D_next), .clk(clk), .Q(Q_internal));\n    assign Q = Q_internal;\nendmodule\n\n//======================================================\n// End of file\n//======================================================\n"
    },
    {
      "title": "SISO",
      "body": "//======================================================\n// 4-bit SISO (Serial-In Serial-Out) SHIFT REGISTER\n// - Truth table (symbolic / next-state relations)\n// - Behavioral model (pos. edge clock)\n// - Dataflow model (combinational next-state -> D-FFs)\n// - Structural model (gate/instance wiring of D-FFs)\n// Single file - suitable for Vivado. No testbench.\n//------------------------------------------------------\n// Conventions used here:\n//  - Q[3] is the MSB (left-most), Q[0] is the LSB (right-most).\n//  - SI is the Serial Input which enters into Q[3] on the next clock (shift-right).\n//  - SO is the Serial Output which is the bit shifted out from Q[0] (previous LSB).\n//  - On each rising edge of clk: {Q3,Q2,Q1,Q0} <= {SI, Q3, Q2, Q1}\n//  - No asynchronous reset or enable is included (keeps modules minimal as requested).\n//======================================================\n\n\n//------------------------------------------------------\n// Small D positive-edge flip-flop primitive used below\n//------------------------------------------------------\nmodule dff_posedge (\n    input  wire D,\n    input  wire clk,\n    output reg  Q\n);\n    always @(posedge clk) begin\n        Q <= D;\n    end\nendmodule\n\n\n//======================================================\n// TRUTH TABLE (symbolic / next-state relations)\n//======================================================\n/*\nSymbolic next-state relations for one clock edge (shift-right, SI enters Q[3]):\n\nCurrent state:  Q = {Q3, Q2, Q1, Q0}\nSerial input:  SI\nNext state:    Q(next) = {Q3_next, Q2_next, Q1_next, Q0_next}\n\n    Q3_next = SI\n    Q2_next = Q3\n    Q1_next = Q2\n    Q0_next = Q1\n    SO       = Q0   // Serial output (bit shifted out)\n\nIf you want an explicit small example:\n\nCurrent Q = 4'b1011 (Q3=1 Q2=0 Q1=1 Q0=1), SI = 0\nNext Q = {SI, Q3, Q2, Q1} = {0,1,0,1} = 4'b0101\nSO (output this clock edge) = previous Q0 = 1\n\nNote: The full enumerated truth table (for all 16 Q states × 2 SI values) follows the same relations above.\n*/\n\n//======================================================\n// 1) BEHAVIORAL MODEL\n//======================================================\nmodule siso_4bit_beh (\n    input  wire SI,        // serial input (enters at MSB Q[3])\n    input  wire clk,\n    output reg  [3:0] Q,   // Q[3] = MSB ... Q[0] = LSB\n    output wire SO         // serial out (previous Q[0])\n);\n    assign SO = Q[0];\n\n    always @(posedge clk) begin\n        // shift-right: new MSB = SI, others take value of the left neighbour\n        Q <= {SI, Q[3], Q[2], Q[1]};\n    end\nendmodule\n\n\n//======================================================\n// 2) DATAFLOW MODEL\n//    - compute D inputs for D-FFs using assign (combinational)\n//    - instantiate 4 dff_posedge to store bits on posedge clk\n//======================================================\nmodule siso_4bit_data (\n    input  wire SI,\n    input  wire clk,\n    output wire [3:0] Q,   // Q[3]..Q[0]\n    output wire SO\n);\n    // internal wires for the Q outputs of the D-FFs\n    wire q3, q2, q1, q0;\n\n    // next-state (D) signals according to shift-right logic\n    wire d3, d2, d1, d0;\n    assign d3 = SI;   // next Q3 = SI\n    assign d2 = q3;   // next Q2 = current Q3\n    assign d1 = q2;   // next Q1 = current Q2\n    assign d0 = q1;   // next Q0 = current Q1\n\n    // instantiate D flip-flops (pos-edge)\n    dff_posedge dff3 (.D(d3), .clk(clk), .Q(q3));\n    dff_posedge dff2 (.D(d2), .clk(clk), .Q(q2));\n    dff_posedge dff1 (.D(d1), .clk(clk), .Q(q1));\n    dff_posedge dff0 (.D(d0), .clk(clk), .Q(q0));\n\n    // pack outputs\n    assign Q = {q3, q2, q1, q0};\n    assign SO = q0;\nendmodule\n\n\n//======================================================\n// 3) STRUCTURAL MODEL\n//    - explicitly wire D-FF instances so next-state connections are obvious\n//======================================================\nmodule siso_4bit_struct (\n    input  wire SI,\n    input  wire clk,\n    output wire [3:0] Q,\n    output wire SO\n);\n    // internal nodes (Q outputs from each D-FF)\n    wire q3, q2, q1, q0;\n\n    // D inputs for each D-FF (wires for clarity)\n    wire d3, d2, d1, d0;\n\n    // Structural next-state wiring (same relations as above)\n    // d3 = SI\n    // d2 = q3\n    // d1 = q2\n    // d0 = q1\n    assign d3 = SI;\n    assign d2 = q3;\n    assign d1 = q2;\n    assign d0 = q1;\n\n    // Instantiate four positive-edge D flip-flops (structural elements)\n    dff_posedge dff_inst3 (.D(d3), .clk(clk), .Q(q3));\n    dff_posedge dff_inst2 (.D(d2), .clk(clk), .Q(q2));\n    dff_posedge dff_inst1 (.D(d1), .clk(clk), .Q(q1));\n    dff_posedge dff_inst0 (.D(d0), .clk(clk), .Q(q0));\n\n    // outputs\n    assign Q = {q3, q2, q1, q0};\n    assign SO = q0;\nendmodule\n\n//======================================================\n// End of file\n//======================================================\n"
    },
    {
      "title": "RIPPLE CARRY",
      "body": "//======================================================\n// 4-BIT RIPPLE CARRY ADDER\n// For Vivado - Includes:\n//   1. Truth Table (commented form)\n//   2. Behavioral Model\n//   3. Dataflow Model\n//   4. Structural Model (using Full Adders)\n//======================================================\n\n\n//======================================================\n// TRUTH TABLE (for 1-bit Full Adder - Base Element)\n//======================================================\n/*\n-------------------------------\n| A | B | Cin | Sum | Cout   |\n-------------------------------\n| 0 | 0 | 0   |  0  |  0    |\n| 0 | 0 | 1   |  1  |  0    |\n| 0 | 1 | 0   |  1  |  0    |\n| 0 | 1 | 1   |  0  |  1    |\n| 1 | 0 | 0   |  1  |  0    |\n| 1 | 0 | 1   |  0  |  1    |\n| 1 | 1 | 0   |  0  |  1    |\n| 1 | 1 | 1   |  1  |  1    |\n-------------------------------\nFor 4-bit Ripple Carry Adder:\n    Inputs:  A[3:0], B[3:0], Cin\n    Outputs: SUM[3:0], Cout\n    Operation: {Cout, SUM} = A + B + Cin\n======================================================\n*/\n\n\n//======================================================\n// 1) BEHAVIORAL MODEL\n//======================================================\nmodule ripple_carry_adder_4bit_beh (\n    input  [3:0] A,\n    input  [3:0] B,\n    input        Cin,\n    output reg [3:0] SUM,\n    output reg       Cout\n);\n    always @(*) begin\n        {Cout, SUM} = A + B + Cin;\n    end\nendmodule\n\n\n//======================================================\n// 2) DATAFLOW MODEL\n//======================================================\nmodule ripple_carry_adder_4bit_data (\n    input  [3:0] A,\n    input  [3:0] B,\n    input        Cin,\n    output [3:0] SUM,\n    output       Cout\n);\n    // Bitwise full-adder equations:\n    wire c1, c2, c3;\n\n    // Sum bits\n    assign SUM[0] = A[0] ^ B[0] ^ Cin;\n    assign c1     = (A[0] & B[0]) | (B[0] & Cin) | (A[0] & Cin);\n\n    assign SUM[1] = A[1] ^ B[1] ^ c1;\n    assign c2     = (A[1] & B[1]) | (B[1] & c1) | (A[1] & c1);\n\n    assign SUM[2] = A[2] ^ B[2] ^ c2;\n    assign c3     = (A[2] & B[2]) | (B[2] & c2) | (A[2] & c2);\n\n    assign SUM[3] = A[3] ^ B[3] ^ c3;\n    assign Cout   = (A[3] & B[3]) | (B[3] & c3) | (A[3] & c3);\nendmodule\n\n\n//======================================================\n// 3) STRUCTURAL MODEL\n//======================================================\n\n// Full Adder Module (Structural base)\nmodule full_adder_struct (\n    input  A,\n    input  B,\n    input  Cin,\n    output Sum,\n    output Cout\n);\n    wire axb, a_and_b, b_and_c, a_and_c;\n\n    xor (axb, A, B);\n    xor (Sum, axb, Cin);\n\n    and (a_and_b, A, B);\n    and (b_and_c, B, Cin);\n    and (a_and_c, A, Cin);\n\n    or (Cout, a_and_b, b_and_c, a_and_c);\nendmodule\n\n// 4-bit Ripple Carry Adder (Structural)\nmodule ripple_carry_adder_4bit_struct (\n    input  [3:0] A,\n    input  [3:0] B,\n    input        Cin,\n    output [3:0] SUM,\n    output       Cout\n);\n    wire c1, c2, c3;\n\n    full_adder_struct fa0 (A[0], B[0], Cin, SUM[0], c1);\n    full_adder_struct fa1 (A[1], B[1], c1,  SUM[1], c2);\n    full_adder_struct fa2 (A[2], B[2], c2,  SUM[2], c3);\n    full_adder_struct fa3 (A[3], B[3], c3,  SUM[3], Cout);\nendmodule\n\n//======================================================\n// END OF FILE\n//======================================================\n"
    },
    {
      "title": "carry look ahead",
      "body": "//======================================================\n// 4-BIT CARRY LOOK-AHEAD ADDER (CLA)\n// For Vivado\n// Includes:\n//   1. Truth Table (commented form)\n//   2. Behavioral Model\n//   3. Dataflow Model\n//   4. Structural Model\n//======================================================\n\n\n//======================================================\n// TRUTH TABLE (for 1-bit Full Adder - Base Unit)\n//======================================================\n/*\n--------------------------------------------------------\n| A | B | Cin | Sum | Cout |\n--------------------------------------------------------\n| 0 | 0 | 0   |  0  |  0   |\n| 0 | 0 | 1   |  1  |  0   |\n| 0 | 1 | 0   |  1  |  0   |\n| 0 | 1 | 1   |  0  |  1   |\n| 1 | 0 | 0   |  1  |  0   |\n| 1 | 0 | 1   |  0  |  1   |\n| 1 | 1 | 0   |  0  |  1   |\n| 1 | 1 | 1   |  1  |  1   |\n--------------------------------------------------------\nFor 4-bit CLA:\nGenerate (G) = A & B\nPropagate (P) = A ^ B\nC1 = G0 + P0·Cin\nC2 = G1 + P1·G0 + P1·P0·Cin\nC3 = G2 + P2·G1 + P2·P1·G0 + P2·P1·P0·Cin\nCout = G3 + P3·G2 + P3·P2·G1 + P3·P2·P1·G0 + P3·P2·P1·P0·Cin\n======================================================\n*/\n\n\n//======================================================\n// 1) BEHAVIORAL MODEL\n//======================================================\nmodule carry_lookahead_adder_4bit_beh (\n    input  [3:0] A,\n    input  [3:0] B,\n    input        Cin,\n    output reg [3:0] SUM,\n    output reg       Cout\n);\n    always @(*) begin\n        {Cout, SUM} = A + B + Cin;\n    end\nendmodule\n\n\n//======================================================\n// 2) DATAFLOW MODEL\n//======================================================\nmodule carry_lookahead_adder_4bit_data (\n    input  [3:0] A,\n    input  [3:0] B,\n    input        Cin,\n    output [3:0] SUM,\n    output       Cout\n);\n    wire [3:0] G, P;   // Generate and Propagate\n    wire [4:0] C;      // Carry signals\n\n    assign C[0] = Cin;\n\n    assign G = A & B;\n    assign P = A ^ B;\n\n    // Carry Look-Ahead Equations\n    assign C[1] = G[0] | (P[0] & C[0]);\n    assign C[2] = G[1] | (P[1] & G[0]) | (P[1] & P[0] & C[0]);\n    assign C[3] = G[2] | (P[2] & G[1]) | (P[2] & P[1] & G[0]) | (P[2] & P[1] & P[0] & C[0]);\n    assign C[4] = G[3] | (P[3] & G[2]) | (P[3] & P[2] & G[1]) |\n                  (P[3] & P[2] & P[1] & G[0]) | (P[3] & P[2] & P[1] & P[0] & C[0]);\n\n    // Sum bits\n    assign SUM  = P ^ C[3:0];\n    assign Cout = C[4];\nendmodule\n\n\n//======================================================\n// 3) STRUCTURAL MODEL\n//======================================================\n\n// Propagate-Generate Unit for one bit\nmodule pg_unit (\n    input  A,\n    input  B,\n    output P,\n    output G\n);\n    xor (P, A, B);\n    and (G, A, B);\nendmodule\n\n\n// Carry Lookahead Logic\nmodule cla_logic (\n    input  [3:0] P,\n    input  [3:0] G,\n    input        Cin,\n    output [4:1] C\n);\n    assign C[1] = G[0] | (P[0] & Cin);\n    assign C[2] = G[1] | (P[1] & G[0]) | (P[1] & P[0] & Cin);\n    assign C[3] = G[2] | (P[2] & G[1]) | (P[2] & P[1] & G[0]) | (P[2] & P[1] & P[0] & Cin);\n    assign C[4] = G[3] | (P[3] & G[2]) | (P[3] & P[2] & G[1]) |\n                  (P[3] & P[2] & P[1] & G[0]) |\n                  (P[3] & P[2] & P[1] & P[0] & Cin);\nendmodule\n\n\n// 4-bit CLA Structural Model\nmodule carry_lookahead_adder_4bit_struct (\n    input  [3:0] A,\n    input  [3:0] B,\n    input        Cin,\n    output [3:0] SUM,\n    output       Cout\n);\n    wire [3:0] P, G;\n    wire [4:1] C;\n\n    // Instantiate Propagate-Generate Units\n    pg_unit pg0 (A[0], B[0], P[0], G[0]);\n    pg_unit pg1 (A[1], B[1], P[1], G[1]);\n    pg_unit pg2 (A[2], B[2], P[2], G[2]);\n    pg_unit pg3 (A[3], B[3], P[3], G[3]);\n\n    // Carry Lookahead Logic\n    cla_logic cla (P, G, Cin, C);\n\n    // Sum bits\n    xor (SUM[0], P[0], Cin);\n    xor (SUM[1], P[1], C[1]);\n    xor (SUM[2], P[2], C[2]);\n    xor (SUM[3], P[3], C[3]);\n\n    // Final Carry Out\n    assign Cout = C[4];\nendmodule\n\n//======================================================\n// END OF FILE\n//======================================================\n"
    },
    {
      "title": "carry skip adder",
      "body": "//======================================================\n// 4-BIT CARRY SKIP ADDER (CSA)\n// For Vivado\n// Includes:\n//   1. Truth Table (commented form)\n//   2. Behavioral Model\n//   3. Dataflow Model\n//   4. Structural Model\n//======================================================\n\n\n//======================================================\n// TRUTH TABLE (for 1-bit Full Adder - Base Unit)\n//======================================================\n/*\n--------------------------------------------------------\n| A | B | Cin | Sum | Cout |\n--------------------------------------------------------\n| 0 | 0 | 0   |  0  |  0   |\n| 0 | 0 | 1   |  1  |  0   |\n| 0 | 1 | 0   |  1  |  0   |\n| 0 | 1 | 1   |  0  |  1   |\n| 1 | 0 | 0   |  1  |  0   |\n| 1 | 0 | 1   |  0  |  1   |\n| 1 | 1 | 0   |  0  |  1   |\n| 1 | 1 | 1   |  1  |  1   |\n--------------------------------------------------------\nCARRY SKIP ADDER:\n- Adds blocks of bits (here 4-bit)\n- Generates block propagate (P_block = P0 & P1 & P2 & P3)\n- If all bits propagate (P_block=1), carry skips over the block\n  Cout = (P_block & Cin) | C4\n======================================================\n*/\n\n\n//======================================================\n// 1) BEHAVIORAL MODEL\n//======================================================\nmodule carry_skip_adder_4bit_beh (\n    input  [3:0] A,\n    input  [3:0] B,\n    input        Cin,\n    output reg [3:0] SUM,\n    output reg       Cout\n);\n    reg [4:0] temp;\n    always @(*) begin\n        temp = A + B + Cin;\n        SUM  = temp[3:0];\n        Cout = temp[4];\n    end\nendmodule\n\n\n//======================================================\n// 2) DATAFLOW MODEL\n//======================================================\nmodule carry_skip_adder_4bit_data (\n    input  [3:0] A,\n    input  [3:0] B,\n    input        Cin,\n    output [3:0] SUM,\n    output       Cout\n);\n    wire [3:0] P, G;\n    wire [4:0] C;\n    wire P_block, Cout_block;\n\n    assign C[0] = Cin;\n\n    // Generate and Propagate\n    assign G = A & B;\n    assign P = A ^ B;\n\n    // Ripple carry inside block\n    assign C[1] = G[0] | (P[0] & C[0]);\n    assign C[2] = G[1] | (P[1] & C[1]);\n    assign C[3] = G[2] | (P[2] & C[2]);\n    assign C[4] = G[3] | (P[3] & C[3]);\n\n    // Sum bits\n    assign SUM = P ^ C[3:0];\n\n    // Block propagate signal\n    assign P_block = P[0] & P[1] & P[2] & P[3];\n\n    // Carry skip logic\n    assign Cout_block = C[4];\n    assign Cout = (P_block & Cin) | Cout_block;\nendmodule\n\n\n//======================================================\n// 3) STRUCTURAL MODEL\n//======================================================\n\n// 1-bit Full Adder\nmodule full_adder (\n    input A, B, Cin,\n    output Sum, Cout\n);\n    wire w1, w2, w3;\n    xor (w1, A, B);\n    xor (Sum, w1, Cin);\n    and (w2, A, B);\n    and (w3, w1, Cin);\n    or  (Cout, w2, w3);\nendmodule\n\n// 4-bit Ripple Carry Block for Carry Skip Adder\nmodule ripple_block (\n    input  [3:0] A,\n    input  [3:0] B,\n    input        Cin,\n    output [3:0] SUM,\n    output [3:0] P,\n    output [4:0] C\n);\n    full_adder fa0 (A[0], B[0], C[0], SUM[0], C[1]);\n    full_adder fa1 (A[1], B[1], C[1], SUM[1], C[2]);\n    full_adder fa2 (A[2], B[2], C[2], SUM[2], C[3]);\n    full_adder fa3 (A[3], B[3], C[3], SUM[3], C[4]);\n\n    assign P[0] = A[0] ^ B[0];\n    assign P[1] = A[1] ^ B[1];\n    assign P[2] = A[2] ^ B[2];\n    assign P[3] = A[3] ^ B[3];\nendmodule\n\n// 4-bit Carry Skip Adder (Structural)\nmodule carry_skip_adder_4bit_struct (\n    input  [3:0] A,\n    input  [3:0] B,\n    input        Cin,\n    output [3:0] SUM,\n    output       Cout\n);\n    wire [3:0] P;\n    wire [4:0] C;\n    wire P_block, Cout_block;\n\n    assign C[0] = Cin;\n\n    ripple_block rb (A, B, Cin, SUM, P, C);\n\n    // Block propagate\n    and (P_block, P[0], P[1], P[2], P[3]);\n\n    // Carry skip\n    or (Cout, Cout_block, P_block & Cin);\n\n    assign Cout_block = C[4];\nendmodule\n\n//======================================================\n// END OF FILE\n//======================================================\n"
    },
    {
      "title": "carry SAVE adder",
      "body": "//======================================================\n// 4-BIT CARRY SAVE ADDER (CSA)\n// For Vivado\n// Includes:\n//   1. Truth Table (commented form)\n//   2. Behavioral Model\n//   3. Dataflow Model\n//   4. Structural Model\n//======================================================\n\n\n//======================================================\n// TRUTH TABLE (for 1-bit Carry Save Adder cell)\n//======================================================\n/*\n--------------------------------------------------------\n| A | B | C | Sum | Carry |\n--------------------------------------------------------\n| 0 | 0 | 0 |  0  |   0   |\n| 0 | 0 | 1 |  1  |   0   |\n| 0 | 1 | 0 |  1  |   0   |\n| 0 | 1 | 1 |  0  |   1   |\n| 1 | 0 | 0 |  1  |   0   |\n| 1 | 0 | 1 |  0  |   1   |\n| 1 | 1 | 0 |  0  |   1   |\n| 1 | 1 | 1 |  1  |   1   |\n--------------------------------------------------------\nCARRY SAVE ADDER:\n- Adds three numbers (A, B, C) in parallel.\n- Produces partial SUM and CARRY outputs (not a final sum).\n- Final addition (if required) is done by ripple or CLA adder.\n======================================================\n*/\n\n\n//======================================================\n// 1) BEHAVIORAL MODEL\n//======================================================\nmodule carry_save_adder_4bit_beh (\n    input  [3:0] A,\n    input  [3:0] B,\n    input  [3:0] C,\n    output reg [3:0] SUM,\n    output reg [3:0] CARRY\n);\n    integer i;\n    always @(*) begin\n        for (i = 0; i < 4; i = i + 1) begin\n            SUM[i]   = A[i] ^ B[i] ^ C[i];\n            CARRY[i] = (A[i] & B[i]) | (B[i] & C[i]) | (A[i] & C[i]);\n        end\n    end\nendmodule\n\n\n//======================================================\n// 2) DATAFLOW MODEL\n//======================================================\nmodule carry_save_adder_4bit_data (\n    input  [3:0] A,\n    input  [3:0] B,\n    input  [3:0] C,\n    output [3:0] SUM,\n    output [3:0] CARRY\n);\n    assign SUM   = A ^ B ^ C;                                // Bitwise XOR for sum\n    assign CARRY = (A & B) | (B & C) | (A & C);              // Carry logic\nendmodule\n\n\n//======================================================\n// 3) STRUCTURAL MODEL\n//======================================================\n\n// 1-bit Carry Save Adder cell\nmodule csa_cell (\n    input A, B, C,\n    output SUM, CARRY\n);\n    wire w1, w2, w3;\n    xor (SUM, A, B, C);\n    and (w1, A, B);\n    and (w2, B, C);\n    and (w3, A, C);\n    or  (CARRY, w1, w2, w3);\nendmodule\n\n// 4-bit Carry Save Adder Structural\nmodule carry_save_adder_4bit_struct (\n    input  [3:0] A,\n    input  [3:0] B,\n    input  [3:0] C,\n    output [3:0] SUM,\n    output [3:0] CARRY\n);\n    csa_cell u0 (A[0], B[0], C[0], SUM[0], CARRY[0]);\n    csa_cell u1 (A[1], B[1], C[1], SUM[1], CARRY[1]);\n    csa_cell u2 (A[2], B[2], C[2], SUM[2], CARRY[2]);\n    csa_cell u3 (A[3], B[3], C[3], SUM[3], CARRY[3]);\nendmodule\n\n//======================================================\n// END OF FILE\n//======================================================\n"
    },
    {
      "title": "wallace",
      "body": "//======================================================\n// 4x4 WALLACE TREE MULTIPLIER (8-bit output)\n// For Vivado\n// Includes:\n//   1. Truth Table (commented form)\n//   2. Behavioral Model\n//   3. Dataflow Model\n//   4. Structural Model\n//======================================================\n\n\n//======================================================\n// TRUTH TABLE (simplified for reference)\n//======================================================\n/*\n--------------------------------------------------------\n|   A (4-bit) |   B (4-bit) |     PRODUCT (8-bit)     |\n--------------------------------------------------------\n|   0000      |   0000      |   00000000              |\n|   0001      |   0010      |   00000010              |\n|   0011      |   0101      |   00001111              |\n|   0101      |   0101      |   00011001              |\n|   1111      |   1111      |   11100001 (225)        |\n--------------------------------------------------------\n- The Wallace Tree reduces partial products using half and full adders.\n- Output is 8 bits (P[7:0]).\n======================================================\n*/\n\n\n//======================================================\n// 1) BEHAVIORAL MODEL\n//======================================================\nmodule wallace_4x4_beh (\n    input  [3:0] A,\n    input  [3:0] B,\n    output reg [7:0] P\n);\n    always @(*) begin\n        P = A * B;\n    end\nendmodule\n\n\n//======================================================\n// 2) DATAFLOW MODEL\n//======================================================\nmodule wallace_4x4_data (\n    input  [3:0] A,\n    input  [3:0] B,\n    output [7:0] P\n);\n    wire [3:0] pp0, pp1, pp2, pp3;\n    wire [7:0] sum1, sum2, sum3;\n\n    // Partial products\n    assign pp0 = A & {4{B[0]}};\n    assign pp1 = A & {4{B[1]}};\n    assign pp2 = A & {4{B[2]}};\n    assign pp3 = A & {4{B[3]}};\n\n    // Shift partial products\n    assign sum1 = {4'b0000, pp0};\n    assign sum2 = {3'b000, pp1, 1'b0};\n    assign sum3 = {2'b00, pp2, 2'b00};\n    wire [7:0] sum4 = {1'b0, pp3, 3'b000};\n\n    // Add them up\n    assign P = sum1 + sum2 + sum3 + sum4;\nendmodule\n\n\n//======================================================\n// 3) STRUCTURAL MODEL\n//======================================================\n\n// 1-bit Half Adder\nmodule half_adder (\n    input A, B,\n    output SUM, CARRY\n);\n    xor (SUM, A, B);\n    and (CARRY, A, B);\nendmodule\n\n// 1-bit Full Adder\nmodule full_adder (\n    input A, B, Cin,\n    output SUM, Cout\n);\n    wire w1, w2, w3;\n    xor (w1, A, B);\n    xor (SUM, w1, Cin);\n    and (w2, A, B);\n    and (w3, w1, Cin);\n    or  (Cout, w2, w3);\nendmodule\n\n\n// Structural Wallace Tree Implementation\nmodule wallace_4x4_struct (\n    input  [3:0] A,\n    input  [3:0] B,\n    output [7:0] P\n);\n    wire [3:0] pp0, pp1, pp2, pp3;\n\n    // Partial products\n    and (pp0[0], A[0], B[0]);\n    and (pp0[1], A[1], B[0]);\n    and (pp0[2], A[2], B[0]);\n    and (pp0[3], A[3], B[0]);\n\n    and (pp1[0], A[0], B[1]);\n    and (pp1[1], A[1], B[1]);\n    and (pp1[2], A[2], B[1]);\n    and (pp1[3], A[3], B[1]);\n\n    and (pp2[0], A[0], B[2]);\n    and (pp2[1], A[1], B[2]);\n    and (pp2[2], A[2], B[2]);\n    and (pp2[3], A[3], B[2]);\n\n    and (pp3[0], A[0], B[3]);\n    and (pp3[1], A[1], B[3]);\n    and (pp3[2], A[2], B[3]);\n    and (pp3[3], A[3], B[3]);\n\n    // Wallace tree reduction stage\n    wire s11, c11, s12, c12, s13, c13, s21, c21, s22, c22, s31, c31;\n\n    // Level 1 reduction\n    half_adder ha1 (pp0[1], pp1[0], s11, c11);\n    full_adder fa1 (pp0[2], pp1[1], pp2[0], s12, c12);\n    full_adder fa2 (pp0[3], pp1[2], pp2[1], s13, c13);\n\n    // Level 2 reduction\n    half_adder ha2 (pp1[3], pp2[2], s21, c21);\n    full_adder fa3 (s13, pp3[0], c12, s22, c22);\n    full_adder fa4 (pp2[3], pp3[1], c13, s31, c31);\n\n    // Final addition\n    assign P[0] = pp0[0];\n    assign P[1] = s11;\n    assign P[2] = s12 ^ c11;\n    assign P[3] = s22 ^ s21;\n    assign P[4] = s31 ^ c21;\n    assign P[5] = pp3[2] ^ c22;\n    assign P[6] = pp3[3] ^ c31;\n    assign P[7] = pp3[3] & c31;\nendmodule\n\n//======================================================\n// END OF FILE\n//======================================================\n"
    },
    {
      "title": "barrel",
      "body": "//======================================================\n// 4-BIT BARREL SHIFTER (Output width = 8-bit for demonstration)\n// For Vivado\n// Includes:\n//   1. Truth Table (commented form)\n//   2. Behavioral Model\n//   3. Dataflow Model\n//   4. Structural Model\n//======================================================\n\n\n//======================================================\n// TRUTH TABLE (for 4-bit Barrel Shifter - Left Shift Example)\n//======================================================\n/*\n--------------------------------------------------------------\n| Input A (4-bit) | Shift[1:0] | Output (8-bit after shift) |\n--------------------------------------------------------------\n| 0001            | 00         | 00000001 (no shift)        |\n| 0001            | 01         | 00000010 (shift left 1)    |\n| 0001            | 10         | 00000100 (shift left 2)    |\n| 0001            | 11         | 00001000 (shift left 3)    |\n--------------------------------------------------------------\nNote:\n- Here we consider a 4-bit input shifted into an 8-bit space.\n- For simplicity, only left shifting is demonstrated.\n======================================================\n*/\n\n\n//======================================================\n// 1) BEHAVIORAL MODEL\n//======================================================\nmodule barrel_shifter_4to8_beh (\n    input  [3:0] A,\n    input  [2:0] Shift,   // up to 7 positions to shift (since output is 8-bit)\n    output reg [7:0] Y\n);\n    always @(*) begin\n        Y = A << Shift;   // behavioral left shift\n    end\nendmodule\n\n\n//======================================================\n// 2) DATAFLOW MODEL\n//======================================================\nmodule barrel_shifter_4to8_data (\n    input  [3:0] A,\n    input  [2:0] Shift,\n    output [7:0] Y\n);\n    // Using combinational shift logic\n    assign Y = A << Shift;\nendmodule\n\n\n//======================================================\n// 3) STRUCTURAL MODEL\n//======================================================\n\n// 1-bit 8x1 multiplexer module\nmodule mux8_1 (\n    input [7:0] D,\n    input [2:0] S,\n    output Y\n);\n    assign Y = (S == 3'b000) ? D[0] :\n               (S == 3'b001) ? D[1] :\n               (S == 3'b010) ? D[2] :\n               (S == 3'b011) ? D[3] :\n               (S == 3'b100) ? D[4] :\n               (S == 3'b101) ? D[5] :\n               (S == 3'b110) ? D[6] :\n                               D[7];\nendmodule\n\n// 4-bit input to 8-bit output Barrel Shifter (Left shift)\nmodule barrel_shifter_4to8_struct (\n    input  [3:0] A,\n    input  [2:0] Shift,\n    output [7:0] Y\n);\n    // For structural clarity, we treat each output bit as a shifted version of A\n    wire [7:0] stage0, stage1, stage2, stage3;\n\n    // Stage 0 (no shift)\n    assign stage0 = {4'b0000, A};\n\n    // Stage 1 (shift left 1)\n    assign stage1 = {3'b000, A, 1'b0};\n\n    // Stage 2 (shift left 2)\n    assign stage2 = {2'b00, A, 2'b00};\n\n    // Stage 3 (shift left 3)\n    assign stage3 = {1'b0, A, 3'b000};\n\n    // Stage 4 (shift left 4)\n    wire [7:0] stage4 = {A, 4'b0000};\n\n    // Multiplexer per output bit\n    mux8_1 m0 ({stage4[0], stage3[0], stage2[0], stage1[0], stage0[0], 3'b000}, Shift, Y[0]);\n    mux8_1 m1 ({stage4[1], stage3[1], stage2[1], stage1[1], stage0[1], 3'b000}, Shift, Y[1]);\n    mux8_1 m2 ({stage4[2], stage3[2], stage2[2], stage1[2], stage0[2], 3'b000}, Shift, Y[2]);\n    mux8_1 m3 ({stage4[3], stage3[3], stage2[3], stage1[3], stage0[3], 3'b000}, Shift, Y[3]);\n    mux8_1 m4 ({stage4[4], stage3[4], stage2[4], stage1[4], stage0[4], 3'b000}, Shift, Y[4]);\n    mux8_1 m5 ({stage4[5], stage3[5], stage2[5], stage1[5], stage0[5], 3'b000}, Shift, Y[5]);\n    mux8_1 m6 ({stage4[6], stage3[6], stage2[6], stage1[6], stage0[6], 3'b000}, Shift, Y[6]);\n    mux8_1 m7 ({stage4[7], stage3[7], stage2[7], stage1[7], stage0[7], 3'b000}, Shift, Y[7]);\nendmodule\n\n//======================================================\n// END OF FILE\n//======================================================\n"
    },
    {
      "title": "fa fs ha hs cadence testbench",
      "body": "//======================================================\n// HALF ADDER\n//======================================================\n\n//---------------- TRUTH TABLE ----------------\n/*\n A | B | SUM | CARRY\n--------------------\n 0 | 0 |  0  |  0\n 0 | 1 |  1  |  0\n 1 | 0 |  1  |  0\n 1 | 1 |  0  |  1\n*/\n\n//---------------- Behavioral Model ----------------\nmodule half_adder_beh(input A, B, output reg SUM, CARRY);\n    always @(*) begin\n        SUM = A ^ B;\n        CARRY = A & B;\n    end\nendmodule\n\n//---------------- Dataflow Model ----------------\nmodule half_adder_data(input A, B, output SUM, CARRY);\n    assign SUM = A ^ B;\n    assign CARRY = A & B;\nendmodule\n\n//---------------- Structural Model ----------------\nmodule xor_gate(input A, B, output Y);\n    assign Y = A ^ B;\nendmodule\n\nmodule and_gate(input A, B, output Y);\n    assign Y = A & B;\nendmodule\n\nmodule half_adder_struct(input A, B, output SUM, CARRY);\n    xor_gate x1(A, B, SUM);\n    and_gate a1(A, B, CARRY);\nendmodule\n\n//---------------- Testbench ----------------\nmodule tb_half_adder;\n    reg A, B;\n    wire SUM, CARRY;\n    half_adder_struct UUT (.A(A), .B(B), .SUM(SUM), .CARRY(CARRY));\n\n    initial begin\n        $monitor(\"Time=%0t | A=%b | B=%b | SUM=%b | CARRY=%b\", $time, A, B, SUM, CARRY);\n        A=0; B=0; #10;\n        A=0; B=1; #10;\n        A=1; B=0; #10;\n        A=1; B=1; #10;\n        $finish;\n    end\nendmodule\n\n\n\n//======================================================\n// FULL ADDER\n//======================================================\n\n//---------------- TRUTH TABLE ----------------\n/*\n A | B | Cin | SUM | CARRY\n---------------------------\n 0 | 0 | 0   |  0  |  0\n 0 | 0 | 1   |  1  |  0\n 0 | 1 | 0   |  1  |  0\n 0 | 1 | 1   |  0  |  1\n 1 | 0 | 0   |  1  |  0\n 1 | 0 | 1   |  0  |  1\n 1 | 1 | 0   |  0  |  1\n 1 | 1 | 1   |  1  |  1\n*/\n\n//---------------- Behavioral Model ----------------\nmodule full_adder_beh(input A, B, Cin, output reg SUM, CARRY);\n    always @(*) begin\n        {CARRY, SUM} = A + B + Cin;\n    end\nendmodule\n\n//---------------- Dataflow Model ----------------\nmodule full_adder_data(input A, B, Cin, output SUM, CARRY);\n    assign SUM = A ^ B ^ Cin;\n    assign CARRY = (A & B) | (B & Cin) | (A & Cin);\nendmodule\n\n//---------------- Structural Model ----------------\nmodule full_adder_struct(input A, B, Cin, output SUM, CARRY);\n    wire s1, c1, c2;\n    half_adder_struct HA1(A, B, s1, c1);\n    half_adder_struct HA2(s1, Cin, SUM, c2);\n    assign CARRY = c1 | c2;\nendmodule\n\n//---------------- Testbench ----------------\nmodule tb_full_adder;\n    reg A, B, Cin;\n    wire SUM, CARRY;\n    full_adder_struct UUT (.A(A), .B(B), .Cin(Cin), .SUM(SUM), .CARRY(CARRY));\n\n    initial begin\n        $monitor(\"A=%b B=%b Cin=%b => SUM=%b CARRY=%b\", A, B, Cin, SUM, CARRY);\n        A=0; B=0; Cin=0; #10;\n        A=0; B=0; Cin=1; #10;\n        A=0; B=1; Cin=0; #10;\n        A=0; B=1; Cin=1; #10;\n        A=1; B=0; Cin=0; #10;\n        A=1; B=0; Cin=1; #10;\n        A=1; B=1; Cin=0; #10;\n        A=1; B=1; Cin=1; #10;\n        $finish;\n    end\nendmodule\n\n\n\n//======================================================\n// HALF SUBTRACTOR\n//======================================================\n\n//---------------- TRUTH TABLE ----------------\n/*\n A | B | DIFF | BORROW\n----------------------\n 0 | 0 |  0   |  0\n 0 | 1 |  1   |  1\n 1 | 0 |  1   |  0\n 1 | 1 |  0   |  0\n*/\n\n//---------------- Behavioral Model ----------------\nmodule half_sub_beh(input A, B, output reg DIFF, BORROW);\n    always @(*) begin\n        DIFF = A ^ B;\n        BORROW = (~A) & B;\n    end\nendmodule\n\n//---------------- Dataflow Model ----------------\nmodule half_sub_data(input A, B, output DIFF, BORROW);\n    assign DIFF = A ^ B;\n    assign BORROW = (~A) & B;\nendmodule\n\n//---------------- Structural Model ----------------\nmodule half_sub_struct(input A, B, output DIFF, BORROW);\n    xor_gate x1(A, B, DIFF);\n    wire nA;\n    not (nA, A);\n    and_gate a1(nA, B, BORROW);\nendmodule\n\n//---------------- Testbench ----------------\nmodule tb_half_sub;\n    reg A, B;\n    wire DIFF, BORROW;\n    half_sub_struct UUT (.A(A), .B(B), .DIFF(DIFF), .BORROW(BORROW));\n\n    initial begin\n        $monitor(\"A=%b B=%b => DIFF=%b BORROW=%b\", A, B, DIFF, BORROW);\n        A=0; B=0; #10;\n        A=0; B=1; #10;\n        A=1; B=0; #10;\n        A=1; B=1; #10;\n        $finish;\n    end\nendmodule\n\n\n\n//======================================================\n// FULL SUBTRACTOR\n//======================================================\n\n//---------------- TRUTH TABLE ----------------\n/*\n A | B | Bin | DIFF | BORROW\n-----------------------------\n 0 | 0 | 0   |  0   |  0\n 0 | 0 | 1   |  1   |  1\n 0 | 1 | 0   |  1   |  1\n 0 | 1 | 1   |  0   |  1\n 1 | 0 | 0   |  1   |  0\n 1 | 0 | 1   |  0   |  0\n 1 | 1 | 0   |  0   |  0\n 1 | 1 | 1   |  1   |  1\n*/\n\n//---------------- Behavioral Model ----------------\nmodule full_sub_beh(input A, B, Bin, output reg DIFF, BORROW);\n    always @(*) begin\n        DIFF = A ^ B ^ Bin;\n        BORROW = (~A & B) | (B & Bin) | (~A & Bin);\n    end\nendmodule\n\n//---------------- Dataflow Model ----------------\nmodule full_sub_data(input A, B, Bin, output DIFF, BORROW);\n    assign DIFF = A ^ B ^ Bin;\n    assign BORROW = (~A & B) | (B & Bin) | (~A & Bin);\nendmodule\n\n//---------------- Structural Model ----------------\nmodule full_sub_struct(input A, B, Bin, output DIFF, BORROW);\n    wire d1, b1, b2;\n    half_sub_struct HS1(A, B, d1, b1);\n    half_sub_struct HS2(d1, Bin, DIFF, b2);\n    assign BORROW = b1 | b2;\nendmodule\n\n//---------------- Testbench ----------------\nmodule tb_full_sub;\n    reg A, B, Bin;\n    wire DIFF, BORROW;\n    full_sub_struct UUT (.A(A), .B(B), .Bin(Bin), .DIFF(DIFF), .BORROW(BORROW));\n\n    initial begin\n        $monitor(\"A=%b B=%b Bin=%b => DIFF=%b BORROW=%b\", A, B, Bin, DIFF, BORROW);\n        A=0; B=0; Bin=0; #10;\n        A=0; B=0; Bin=1; #10;\n        A=0; B=1; Bin=0; #10;\n        A=0; B=1; Bin=1; #10;\n        A=1; B=0; Bin=0; #10;\n        A=1; B=0; Bin=1; #10;\n        A=1; B=1; Bin=0; #10;\n        A=1; B=1; Bin=1; #10;\n        $finish;\n    end\nendmodule\n"
    },
    {
      "title": "Topic 12",
      "body": "Pasteable content for Topic 12"
    },
    {
      "title": "Topic 13",
      "body": "Pasteable content for Topic 13"
    },
    {
      "title": "Topic 14",
      "body": "Pasteable content for Topic 14"
    },
    {
      "title": "Topic 15",
      "body": "Pasteable content for Topic 15"
    }
  ]
}